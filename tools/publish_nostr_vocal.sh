#!/bin/bash
################################################################################
# publish_nostr_vocal.sh - NOSTR Voice Message Event Publisher (NIP-A0)
#
# This script publishes NIP-A0 voice message events (kind 1222/1244) to NOSTR relays.
# It is designed to work in HARMONY with upload2ipfs.sh:
#
# WORKFLOW:
#   1. upload2ipfs.sh: Upload audio file to IPFS, generate metadata (info.json)
#   2. publish_nostr_vocal.sh: Publish NOSTR event with metadata from step 1
#
# The --auto mode allows seamless integration by reading upload2ipfs.sh JSON output.
#
# USAGE:
#   # Manual mode (all parameters explicit)
#   ./publish_nostr_vocal.sh --nsec <nsec_key_or_file> \
#                            --ipfs-cid <cid> \
#                            --filename <name> \
#                            [--title "My Voice Message"] \
#                            [--description "Voice description"] \
#                            [--info-cid <cid>] \
#                            [--file-hash <sha256>] \
#                            [--mime-type "audio/mp4"] \
#                            [--duration <seconds>] \
#                            [--waveform "0 7 35 8 100..."] \
#                            [--latitude <lat>] \
#                            [--longitude <lon>] \
#                            [--channel <name>] \
#                            [--kind 1222] \
#                            [--reply-to-event-id <event_id>] \
#                            [--reply-to-pubkey <pubkey>] \
#                            [--expiration <unix_timestamp>] \
#                            [--encrypted "true"] \
#                            [--encryption-method "nip44"] \
#                            [--recipients '["npub1...","npub2..."]'] \
#                            [--relays "ws://host1,wss://host2"] \
#                            [--json]
#
#   # Auto mode (reads from upload2ipfs.sh output file)
#   ./publish_nostr_vocal.sh --auto <upload_output.json> \
#                            --nsec <nsec_key_or_file> \
#                            [--title "My Voice Message"] \
#                            [--description "..."] \
#                            [--channel <name>] \
#                            [--kind 1222] \
#                            [--json]
#
# RETURNS:
#   - Exit code 0 on success
#   - JSON output if --json flag is set
#   - Event ID printed to stdout
#
# EXAMPLES:
#   # Example 1: Root voice message (kind 1222)
#   ./publish_nostr_vocal.sh --nsec ~/.zen/game/players/user@example.com/.secret.nostr \
#                            --ipfs-cid QmXXX \
#                            --filename voice.m4a \
#                            --title "Hello World" \
#                            --duration 30 \
#                            --json
#
#   # Example 2: Reply voice message (kind 1244)
#   ./publish_nostr_vocal.sh --nsec ~/.zen/game/players/user@example.com/.secret.nostr \
#                            --ipfs-cid QmYYY \
#                            --filename reply.m4a \
#                            --title "Re: Hello World" \
#                            --kind 1244 \
#                            --reply-to-event-id abc123... \
#                            --reply-to-pubkey def456... \
#                            --json
#
#   # Example 3: With expiration (NIP-40)
#   ./publish_nostr_vocal.sh --nsec ~/.zen/game/players/user@example.com/.secret.nostr \
#                            --ipfs-cid QmXXX \
#                            --filename voice.m4a \
#                            --title "Temporary Reminder" \
#                            --expiration 1752600000 \
#                            --json
#
# HARMONY WITH upload2ipfs.sh:
#   This script expects metadata generated by upload2ipfs.sh:
#   - IPFS CID (main audio file)
#   - info.json CID (contains all metadata)
#   - file hash (SHA256, for provenance tracking)
#   - upload_chain (provenance: list of pubkeys that uploaded this file)
#
#   Upload2ipfs.sh should be called FIRST to generate these metadata,
#   then this script publishes the NOSTR event with complete metadata.
#
################################################################################

# Note: set -e removed to allow proper error handling with exit codes
# set -e
# Find uSPOT ENV
source $HOME/.zen/Astroport.ONE/tools/my.sh

# Default values
RELAYS="ws://127.0.0.1:7777,wss://relay.copylaradio.com"
MIME_TYPE="audio/mp4"
DURATION=0
LATITUDE="0.00"
LONGITUDE="0.00"
JSON_OUTPUT=false
AUTO_MODE=false
AUTO_FILE=""
NOSTR_SCRIPT="${HOME}/.zen/Astroport.ONE/tools/nostr_send_note.py"
VOICE_KIND="1222"  # Default: root message (1222) or reply (1244)
REPLY_TO_EVENT_ID=""
REPLY_TO_PUBKEY=""
EXPIRATION=""
ENCRYPTED="false"
ENCRYPTION_METHOD="nip44"
RECIPIENTS=""
WAVEFORM=""
CONTENT=""  # Optional: encrypted content (if provided, will be used instead of building from title/description)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored messages
log_info() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${BLUE}â„¹${NC} $1" >&2
    fi
}

log_success() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${GREEN}âœ“${NC} $1" >&2
    fi
}

log_error() {
    echo -e "${RED}âœ—${NC} $1" >&2
}

log_warning() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${YELLOW}âš ${NC} $1" >&2
    fi
}

# Function to print usage
usage() {
    cat << EOF
Usage: $0 --nsec <nsec_key_or_file> --ipfs-cid <cid> --filename <name> [OPTIONS]

Required arguments:
  --nsec <key_or_file>      NSEC private key (nsec1...) or path to .secret.nostr file
  --ipfs-cid <cid>          IPFS CID of the audio file
  --filename <name>         Filename of the audio file

Optional arguments:
  --title <text>            Voice message title (default: auto-generated from timestamp)
  --description <text>      Voice message description
  --info-cid <cid>          IPFS CID of info.json metadata file
  --file-hash <sha256>      SHA256 hash of the audio file (for provenance)
  --mime-type <type>        MIME type (default: audio/mp4)
  --upload-chain <chain>    Upload chain for provenance tracking
  --duration <seconds>      Audio duration in seconds
  --waveform <data>         Waveform data (space-separated integers)
  --latitude <lat>          Geographic latitude (default: 0.00)
  --longitude <lon>         Geographic longitude (default: 0.00)
  --channel <name>          Channel name/email
  --kind <1222|1244>        Event kind: 1222 (root) or 1244 (reply) (default: 1222)
  --reply-to-event-id <id>   Event ID being replied to (required for kind 1244)
  --reply-to-pubkey <key>   Pubkey of the event being replied to (required for kind 1244)
  --expiration <timestamp>  Expiration timestamp (NIP-40, Unix timestamp)
  --encrypted <true|false>  Whether message is encrypted (default: false)
  --encryption-method <method>  Encryption method: nip44 or nip04 (default: nip44)
  --recipients <json_array> JSON array of recipient pubkeys (for encrypted messages)
  --content <text>         Optional: encrypted content or custom content (if provided, overrides title/description)
  --relays <urls>           Comma-separated relay URLs (default: local+copylaradio)
  --json                    Output JSON format
  --help                    Show this help message

Examples:
  # Root voice message
  $0 --nsec ~/.zen/game/players/user@example.com/.secret.nostr \\
     --ipfs-cid QmXXX \\
     --filename voice.m4a \\
     --title "Hello World" \\
     --duration 30 \\
     --json

  # Reply voice message
  $0 --nsec ~/.zen/game/players/user@example.com/.secret.nostr \\
     --ipfs-cid QmYYY \\
     --filename reply.m4a \\
     --title "Re: Hello" \\
     --kind 1244 \\
     --reply-to-event-id abc123... \\
     --reply-to-pubkey def456... \\
     --json

  # With expiration
  $0 --nsec ~/.zen/game/players/user@example.com/.secret.nostr \\
     --ipfs-cid QmXXX \\
     --filename voice.m4a \\
     --title "Temporary" \\
     --expiration 1752600000 \\
     --json
EOF
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto)
            AUTO_MODE=true
            AUTO_FILE="$2"
            shift 2
            ;;
        --nsec)
            NSEC_INPUT="$2"
            shift 2
            ;;
        --ipfs-cid)
            IPFS_CID="$2"
            shift 2
            ;;
        --filename)
            FILENAME="$2"
            shift 2
            ;;
        --title)
            TITLE="$2"
            shift 2
            ;;
        --description)
            DESCRIPTION="$2"
            shift 2
            ;;
        --info-cid)
            INFO_CID="$2"
            shift 2
            ;;
        --file-hash)
            FILE_HASH="$2"
            shift 2
            ;;
        --mime-type)
            MIME_TYPE="$2"
            shift 2
            ;;
        --upload-chain)
            UPLOAD_CHAIN="$2"
            shift 2
            ;;
        --duration)
            DURATION="$2"
            shift 2
            ;;
        --waveform)
            WAVEFORM="$2"
            shift 2
            ;;
        --latitude)
            LATITUDE="$2"
            shift 2
            ;;
        --longitude)
            LONGITUDE="$2"
            shift 2
            ;;
        --channel)
            CHANNEL="$2"
            shift 2
            ;;
        --kind)
            VOICE_KIND="$2"
            shift 2
            ;;
        --reply-to-event-id)
            REPLY_TO_EVENT_ID="$2"
            shift 2
            ;;
        --reply-to-pubkey)
            REPLY_TO_PUBKEY="$2"
            shift 2
            ;;
        --expiration)
            EXPIRATION="$2"
            shift 2
            ;;
        --encrypted)
            ENCRYPTED="$2"
            shift 2
            ;;
        --encryption-method)
            ENCRYPTION_METHOD="$2"
            shift 2
            ;;
        --recipients)
            RECIPIENTS="$2"
            shift 2
            ;;
        --content)
            CONTENT="$2"
            shift 2
            ;;
        --relays)
            RELAYS="$2"
            shift 2
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Auto mode: load parameters from upload2ipfs.sh output file
if [ "$AUTO_MODE" = "true" ]; then
    log_info "Auto mode enabled, reading from: $AUTO_FILE"
    
    if [ -z "$AUTO_FILE" ] || [ ! -f "$AUTO_FILE" ]; then
        log_error "Auto mode requires a valid upload2ipfs.sh output file"
        exit 1
    fi
    
    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        log_error "jq is required for auto mode"
        exit 1
    fi
    
    # Read JSON output from upload2ipfs.sh
    UPLOAD_DATA=$(cat "$AUTO_FILE")
    
    # Extract fields (only if not already provided via command line)
    [ -z "$IPFS_CID" ] && IPFS_CID=$(echo "$UPLOAD_DATA" | jq -r '.new_cid // .cid // empty')
    [ -z "$FILENAME" ] && FILENAME=$(echo "$UPLOAD_DATA" | jq -r '.fileName // empty')
    [ -z "$FILE_HASH" ] && FILE_HASH=$(echo "$UPLOAD_DATA" | jq -r '.fileHash // empty')
    [ -z "$MIME_TYPE" ] && MIME_TYPE=$(echo "$UPLOAD_DATA" | jq -r '.mimeType // "audio/mp4"')
    [ -z "$INFO_CID" ] && INFO_CID=$(echo "$UPLOAD_DATA" | jq -r '.info // empty')
    [ -z "$UPLOAD_CHAIN" ] && UPLOAD_CHAIN=$(echo "$UPLOAD_DATA" | jq -r '.upload_chain // empty')
    
    # Extract duration (convert to integer)
    if [ -z "$DURATION" ] || [ "$DURATION" = "0" ]; then
        DURATION_RAW=$(echo "$UPLOAD_DATA" | jq -r '.duration // 0')
        DURATION=$(echo "$DURATION_RAW" | awk '{print int($1)}')
    else
        # Convert duration to integer if it's a decimal
        DURATION=$(echo "$DURATION" | awk '{print int($1)}')
    fi
    
    # Auto-generate title if not provided
    if [ -z "$TITLE" ]; then
        TITLE=$(echo "$UPLOAD_DATA" | jq -r '.title // empty')
        if [ -z "$TITLE" ]; then
            TITLE="Voice Message $(date '+%Y-%m-%d %H:%M')"
        fi
    fi
    
    log_success "Loaded metadata from upload2ipfs.sh output"
    log_info "  CID: $IPFS_CID"
    log_info "  Filename: $FILENAME"
    log_info "  Duration: ${DURATION}s"
    [ -n "$INFO_CID" ] && log_info "  Info CID: ${INFO_CID:0:16}..."
    [ -n "$UPLOAD_CHAIN" ] && log_info "  Upload chain: ${UPLOAD_CHAIN:0:50}..."
fi

# Validate required arguments
if [ -z "$NSEC_INPUT" ]; then
    log_error "Missing required argument: --nsec"
    usage
fi

if [ -z "$IPFS_CID" ]; then
    log_error "Missing required argument: --ipfs-cid (or --auto with valid file)"
    usage
fi

if [ -z "$FILENAME" ]; then
    log_error "Missing required argument: --filename (or --auto with valid file)"
    usage
fi

# Validate kind
if [ "$VOICE_KIND" != "1222" ] && [ "$VOICE_KIND" != "1244" ]; then
    log_error "Invalid kind: $VOICE_KIND (must be 1222 or 1244)"
    usage
fi

# Validate reply parameters for kind 1244
if [ "$VOICE_KIND" = "1244" ]; then
    if [ -z "$REPLY_TO_EVENT_ID" ] || [ -z "$REPLY_TO_PUBKEY" ]; then
        log_error "Kind 1244 (reply) requires --reply-to-event-id and --reply-to-pubkey"
        usage
    fi
fi

# Extract NSEC key
if [ -f "$NSEC_INPUT" ]; then
    # It's a file, extract NSEC from it
    log_info "Reading NSEC from file: $NSEC_INPUT"
    NSEC_KEY=$(grep -oP 'NSEC=\K[^\s;]+' "$NSEC_INPUT" 2>/dev/null || echo "")
    if [ -z "$NSEC_KEY" ]; then
        log_error "Could not extract NSEC from file: $NSEC_INPUT"
        exit 1
    fi
    KEYFILE="$NSEC_INPUT"
else
    # Assume it's a direct NSEC key
    NSEC_KEY="$NSEC_INPUT"
    # Create temporary keyfile
    TEMP_KEYFILE=$(mktemp)
    echo "NSEC=$NSEC_KEY" > "$TEMP_KEYFILE"
    KEYFILE="$TEMP_KEYFILE"
    log_info "Using provided NSEC key"
fi

# Generate default title if not provided
if [ -z "$TITLE" ]; then
    TITLE="Voice Message $(date '+%Y-%m-%d %H:%M')"
    log_info "Using default title: $TITLE"
fi

# Ensure DURATION is an integer (convert if decimal)
if [ -n "$DURATION" ] && [ "$DURATION" != "0" ]; then
    DURATION=$(echo "$DURATION" | awk '{print int($1)}')
fi
# Default to 0 if not set
DURATION=${DURATION:-0}

# Build IPFS URL
# Encode the filename for URL safety
ENCODED_FILENAME=$(python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))" "$FILENAME")
IPFS_URL="/ipfs/${IPFS_CID}/${ENCODED_FILENAME}"
log_info "IPFS URL: $IPFS_URL"

# Build voice message content
# If --content is provided (e.g., encrypted content), use it directly
# Otherwise, build from title and description
if [ -n "$CONTENT" ] && [ "$CONTENT" != "" ]; then
    VOICE_CONTENT="$CONTENT"
    log_info "Using provided content (encrypted or custom)"
else
    VOICE_CONTENT="ðŸŽ¤ ${TITLE}"
    if [ -n "$DESCRIPTION" ]; then
        VOICE_CONTENT="${VOICE_CONTENT}
ðŸ“ Description: ${DESCRIPTION}"
    fi
fi

log_info "Building NOSTR tags..."

# Build imeta tag according to NIP-92 specification
# Format: ["imeta", "url /ipfs/QmCID", "duration 45", "waveform ...", "title ...", "description ..."]
IMETA_TAG_ARRAY="[\"imeta\""
IMETA_TAG_ARRAY="${IMETA_TAG_ARRAY}, \"url ${IPFS_URL}\""

# Add duration in imeta (floating point seconds)
if [ -n "$DURATION" ] && [ "$DURATION" != "0" ]; then
    # Convert to floating point if needed
    DURATION_FLOAT=$(echo "$DURATION" | awk '{printf "%.3f", $1}')
    IMETA_TAG_ARRAY="${IMETA_TAG_ARRAY}, \"duration ${DURATION_FLOAT}\""
fi

# Add waveform if provided
if [ -n "$WAVEFORM" ]; then
    IMETA_TAG_ARRAY="${IMETA_TAG_ARRAY}, \"waveform ${WAVEFORM}\""
fi

# Add title and description to imeta
if [ -n "$TITLE" ]; then
    # Escape quotes in title
    ESCAPED_TITLE=$(echo "$TITLE" | sed 's/"/\\"/g')
    IMETA_TAG_ARRAY="${IMETA_TAG_ARRAY}, \"title ${ESCAPED_TITLE}\""
fi

if [ -n "$DESCRIPTION" ]; then
    # Escape quotes in description
    ESCAPED_DESC=$(echo "$DESCRIPTION" | sed 's/"/\\"/g')
    IMETA_TAG_ARRAY="${IMETA_TAG_ARRAY}, \"description ${ESCAPED_DESC}\""
fi

IMETA_TAG_ARRAY="${IMETA_TAG_ARRAY}]"

# Build tags array (compatible with NIP-A0)
TAGS='[
    ["title", "'"$TITLE"'"],
    ["url", "'"$IPFS_URL"'"],
    '"$IMETA_TAG_ARRAY"'
'

# Add description tag if provided
if [ -n "$DESCRIPTION" ]; then
    ESCAPED_DESC=$(echo "$DESCRIPTION" | sed 's/"/\\"/g')
    TAGS="${TAGS},
    [\"description\", \"${ESCAPED_DESC}\"]"
fi

# Add file hash tag (provenance)
if [ -n "$FILE_HASH" ]; then
    TAGS="${TAGS},
    [\"x\", \"${FILE_HASH}\"]"
    log_info "Added file hash: ${FILE_HASH:0:16}..."
fi

# Add expiration tag (NIP-40)
if [ -n "$EXPIRATION" ] && [ "$EXPIRATION" != "" ]; then
    # Validate expiration is a valid Unix timestamp
    if echo "$EXPIRATION" | grep -qE '^[0-9]+$'; then
        TAGS="${TAGS},
    [\"expiration\", \"${EXPIRATION}\"]"
        log_info "Added expiration tag (NIP-40): $EXPIRATION"
    else
        log_warning "Invalid expiration timestamp, skipping: $EXPIRATION"
    fi
fi

# Add encryption tags if encrypted
if [ "$ENCRYPTED" = "true" ]; then
    TAGS="${TAGS},
    [\"encrypted\", \"true\"],
    [\"encryption\", \"${ENCRYPTION_METHOD}\"]"
    log_info "Added encryption tags: method=${ENCRYPTION_METHOD}"
    
    # Add recipient tags (p tags)
    if [ -n "$RECIPIENTS" ] && [ "$RECIPIENTS" != "" ]; then
        # Parse JSON array and add each recipient as p tag
        if command -v jq &> /dev/null; then
            while IFS= read -r recipient; do
                if [ -n "$recipient" ] && [ "$recipient" != "null" ]; then
                    # Convert npub to hex if needed
                    if [[ "$recipient" =~ ^npub1 ]]; then
                        # Try to convert npub to hex using nostr2hex.py if available
                        HEX_RECIPIENT=""
                        if [ -f "${MY_PATH}/tools/nostr2hex.py" ]; then
                            HEX_RECIPIENT=$("${MY_PATH}/tools/nostr2hex.py" "$recipient" 2>/dev/null || echo "")
                        fi
                        if [ -n "$HEX_RECIPIENT" ]; then
                            TAGS="${TAGS},
    [\"p\", \"${HEX_RECIPIENT}\"]"
                            log_info "Added recipient (converted from npub): ${HEX_RECIPIENT:0:16}..."
                        else
                            # Keep npub format if conversion fails
                            TAGS="${TAGS},
    [\"p\", \"${recipient}\"]"
                            log_info "Added recipient (npub): ${recipient:0:16}..."
                        fi
                    else
                        # Assume hex format
                        TAGS="${TAGS},
    [\"p\", \"${recipient}\"]"
                        log_info "Added recipient (hex): ${recipient:0:16}..."
                    fi
                fi
            done < <(echo "$RECIPIENTS" | jq -r '.[]' 2>/dev/null)
        else
            log_warning "jq not available, cannot parse recipients JSON array"
        fi
    fi
fi

# Add channel tag if provided
if [ -n "$CHANNEL" ]; then
    CHANNEL_TAG=$(echo "$CHANNEL" | sed 's/@/_/g; s/\./_/g')
    TAGS="${TAGS},
    [\"t\", \"Channel-${CHANNEL_TAG}\"]"
    log_info "Added channel tag: Channel-${CHANNEL_TAG}"
fi

# Add geographic coordinates (UMAP anchoring)
GEOHASH=""
if command -v python3 &> /dev/null; then
    # Try to use Python's geohash library if available
    GEOHASH=$(python3 -c "
try:
    import geohash
    print(geohash.encode($LATITUDE, $LONGITUDE))
except ImportError:
    pass
except Exception:
    pass
" 2>/dev/null || echo "")
fi

# If geohash not available, use coordinates format
if [ -z "$GEOHASH" ]; then
    GEOHASH="${LATITUDE},${LONGITUDE}"
    log_info "Using coordinate format for geohash (geohash library not available)"
else
    log_info "Converted coordinates to geohash: $GEOHASH"
fi

if [ "$LATITUDE" != "0.00" ] || [ "$LONGITUDE" != "0.00" ]; then
    TAGS="${TAGS},
    [\"g\", \"${GEOHASH}\"],
    [\"latitude\", \"${LATITUDE}\"],
    [\"longitude\", \"${LONGITUDE}\"]"
    log_info "Added location: ${LATITUDE}, ${LONGITUDE} (geohash: ${GEOHASH})"
fi

# Add info.json CID if available
if [ -n "$INFO_CID" ]; then
    TAGS="${TAGS},
    [\"info\", \"${INFO_CID}\"]"
    log_info "Added info.json CID: ${INFO_CID}"
fi

# Add upload_chain if this is a re-upload
if [ -n "$UPLOAD_CHAIN" ]; then
    # Use jq to properly escape the JSON string for insertion into tags array
    if command -v jq &> /dev/null; then
        ESCAPED_CHAIN=$(echo "$UPLOAD_CHAIN" | jq -Rs '.' | head -c -1)
        TAGS="${TAGS},
    [\"upload_chain\", ${ESCAPED_CHAIN}]"
    else
        ESCAPED_CHAIN=$(echo "$UPLOAD_CHAIN" | sed 's/"/\\"/g' | tr '\n' ' ' | sed 's/  */ /g')
        TAGS="${TAGS},
    [\"upload_chain\", \"${ESCAPED_CHAIN}\"]"
    fi
    log_info "Added upload chain: ${UPLOAD_CHAIN:0:50}..."
fi

# Add reply tags for kind 1244 (NIP-22)
if [ "$VOICE_KIND" = "1244" ] && [ -n "$REPLY_TO_EVENT_ID" ] && [ -n "$REPLY_TO_PUBKEY" ]; then
    # Get first relay URL for e tag
    FIRST_RELAY=$(echo "$RELAYS" | cut -d',' -f1 | tr -d ' ')
    
    # Add e tag (event reference) - NIP-22 format: ["e", <event-id>, <relay-url>, "reply"]
    TAGS="${TAGS},
    [\"e\", \"${REPLY_TO_EVENT_ID}\", \"${FIRST_RELAY}\", \"reply\"]"
    log_info "Added reply event reference (e): ${REPLY_TO_EVENT_ID:0:16}..."
    
    # Add p tag (pubkey reference) - NIP-22 format: ["p", <pubkey>]
    # Convert npub to hex if needed
    HEX_PUBKEY="$REPLY_TO_PUBKEY"
    if [[ "$REPLY_TO_PUBKEY" =~ ^npub1 ]]; then
        if [ -f "${MY_PATH}/tools/nostr2hex.py" ]; then
            HEX_PUBKEY=$("${MY_PATH}/tools/nostr2hex.py" "$REPLY_TO_PUBKEY" 2>/dev/null || echo "$REPLY_TO_PUBKEY")
        fi
    fi
    TAGS="${TAGS},
    [\"p\", \"${HEX_PUBKEY}\"]"
    log_info "Added reply author reference (p): ${HEX_PUBKEY:0:16}..."
    
    # For nested replies, we might need to find the root event
    # For now, we'll use the parent event as both root and reply
    # Clients can build the thread structure from e tags
fi

# Close tags array
TAGS="${TAGS}
]"

# Check if nostr_send_note.py exists
if [ ! -f "$NOSTR_SCRIPT" ]; then
    log_error "NOSTR script not found: $NOSTR_SCRIPT"
    if [ -n "$TEMP_KEYFILE" ]; then
        rm -f "$TEMP_KEYFILE"
    fi
    exit 1
fi

# Publish to NOSTR
log_info "Publishing to NOSTR relays..."
log_info "Command: python3 $NOSTR_SCRIPT --keyfile <keyfile> --content <content> --relays $RELAYS --tags <tags> --kind $VOICE_KIND --json"

# Determine which Python3 to use (prefer ~/.astro/bin/python3 if available)
PYTHON_CMD="python3"
if [ -x "$HOME/.astro/bin/python3" ]; then
    PYTHON_CMD="$HOME/.astro/bin/python3"
elif [ -x "/usr/bin/python3" ]; then
    PYTHON_CMD="/usr/bin/python3"
fi

log_info "Using Python: $PYTHON_CMD"

# Execute nostr_send_note.py
NOSTR_OUTPUT=$($PYTHON_CMD "$NOSTR_SCRIPT" \
    --keyfile "$KEYFILE" \
    --content "$VOICE_CONTENT" \
    --relays "$RELAYS" \
    --tags "$TAGS" \
    --kind "$VOICE_KIND" \
    --json 2>&1)

NOSTR_EXIT_CODE=$?

# Clean up temporary keyfile if created
if [ -n "$TEMP_KEYFILE" ]; then
    rm -f "$TEMP_KEYFILE"
fi

# Check result
if [ $NOSTR_EXIT_CODE -eq 0 ]; then
    # Parse JSON output
    EVENT_ID=$(echo "$NOSTR_OUTPUT" | jq -r '.event_id // empty' 2>/dev/null || echo "")
    RELAYS_SUCCESS=$(echo "$NOSTR_OUTPUT" | jq -r '.relays_success // 0' 2>/dev/null || echo "0")
    RELAYS_TOTAL=$(echo "$NOSTR_OUTPUT" | jq -r '.relays_total // 0' 2>/dev/null || echo "0")
    
    if [ -z "$EVENT_ID" ]; then
        # Fallback to old parsing method
        EVENT_ID=$(echo "$NOSTR_OUTPUT" | grep -oP '(Event ID:|event_id:|- ID:)\s*\K[a-f0-9]{64}' | head -1 || echo "")
    fi
    
    if [ -n "$EVENT_ID" ]; then
        log_success "NOSTR voice message published successfully!"
        log_success "Event ID: $EVENT_ID"
        log_success "Kind: $VOICE_KIND"
        log_success "Published to $RELAYS_SUCCESS/$RELAYS_TOTAL relay(s)"
        
        if [ "$JSON_OUTPUT" = "true" ]; then
            # Output JSON format
            cat << EOF
{
  "success": true,
  "event_id": "$EVENT_ID",
  "kind": $VOICE_KIND,
  "relays_success": $RELAYS_SUCCESS,
  "relays_total": $RELAYS_TOTAL,
  "ipfs_url": "$IPFS_URL",
  "title": "$TITLE",
  "duration": $DURATION
}
EOF
        else
            echo "$EVENT_ID"
        fi
        exit 0
    else
        log_error "Event published but could not extract event ID"
        log_error "Output: $NOSTR_OUTPUT"
        exit 1
    fi
else
    log_error "Failed to publish NOSTR event (exit code: $NOSTR_EXIT_CODE)"
    log_error "Output: $NOSTR_OUTPUT"
    if [ "$JSON_OUTPUT" = "true" ]; then
        cat << EOF
{
  "success": false,
  "error": "Failed to publish NOSTR event",
  "exit_code": $NOSTR_EXIT_CODE,
  "output": "$NOSTR_OUTPUT"
}
EOF
    fi
    exit 1
fi

