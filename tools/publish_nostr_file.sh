#!/bin/bash
################################################################################
# publish_nostr_file.sh - Unified NOSTR File Event Publisher (NIP-94 + NIP-71)
#
# This script publishes file metadata events to NOSTR relays:
# - Kind 1063 (NIP-94): File metadata for general files
# - Kind 21/22 (NIP-71): Video events (delegates to publish_nostr_video.sh)
#
# It is designed to work in HARMONY with upload2ipfs.sh:
#
# WORKFLOW:
#   1. upload2ipfs.sh: Upload file to IPFS, generate metadata
#   2. publish_nostr_file.sh: Publish NOSTR event based on file type
#
# The --auto mode allows seamless integration by reading upload2ipfs.sh JSON output.
#
# USAGE:
#   # Auto mode (RECOMMENDED - reads from upload2ipfs.sh output)
#   ./publish_nostr_file.sh --auto <upload_output.json> \
#                           --nsec <nsec_key_or_file> \
#                           [--title "My File"] \
#                           [--description "..."] \
#                           [--json]
#
#   # Manual mode
#   ./publish_nostr_file.sh --nsec <nsec_key_or_file> \
#                           --ipfs-cid <cid> \
#                           --filename <name> \
#                           --mime-type <type> \
#                           [--file-hash <sha256>] \
#                           [--info-cid <cid>] \
#                           [--upload-chain "..."] \
#                           [--json]
#
# RETURNS:
#   - Exit code 0 on success
#   - JSON output if --json flag is set
#   - Event ID printed to stdout
#
# EXAMPLES:
#   # Example 1: Integrated with upload2ipfs.sh (RECOMMENDED)
#   UPLOAD_OUTPUT="/tmp/upload_result.json"
#   upload2ipfs.sh document.pdf "$UPLOAD_OUTPUT" "$USER_HEX"
#   publish_nostr_file.sh --auto "$UPLOAD_OUTPUT" \
#                         --nsec ~/.zen/game/players/user@example.com/.secret.nostr \
#                         --title "My Document" \
#                         --json
#
#   # Example 2: Image file
#   publish_nostr_file.sh --auto /tmp/image_upload.json \
#                         --nsec ~/.zen/secret.nostr \
#                         --json
#
#   # Example 3: Video file (delegates to publish_nostr_video.sh)
#   publish_nostr_file.sh --auto /tmp/video_upload.json \
#                         --nsec ~/.zen/secret.nostr \
#                         --title "My Video" \
#                         --json
#
# FILE TYPE DETECTION AND METADATA:
#   - video/* → Delegates to publish_nostr_video.sh (kind 21/22, NIP-71)
#                Tags: duration, thumbnail, gifanim, dimensions, imeta
#   
#   - image/* → NIP-94 kind 1063 with image-specific tags:
#                • dim (dimensions, e.g. "1920x1080")
#                • thumbnail_ipfs (JPG thumbnail for non-JPG images)
#                • r (thumbnail URL with "Thumbnail" label)
#                • image (thumbnail URL for preview)
#   
#   - audio/* → NIP-94 kind 1063 with audio-specific tags:
#                • duration (in seconds)
#   
#   - text/*  → NIP-94 kind 1063 with text content preview
#   - */*     → NIP-94 kind 1063 with generic metadata
#
# HARMONY WITH upload2ipfs.sh:
#   This script expects metadata generated by upload2ipfs.sh:
#   - IPFS CID (main file)
#   - MIME type (for kind determination)
#   - file hash (SHA256, for provenance tracking)
#   - upload_chain (provenance: list of pubkeys)
#   - info.json CID (contains all metadata)
#   
#   Type-specific metadata from upload2ipfs.sh:
#   - Images: dimensions, thumbnail_ipfs (for non-JPG)
#   - Audio: duration
#   - Videos: duration, dimensions, thumbnail_ipfs, gifanim_ipfs
#
#   Upload2ipfs.sh should be called FIRST to generate these metadata.
#
################################################################################

# Note: set -e removed to allow proper error handling with exit codes
# set -e
# Find uSPOT ENV
source $HOME/.zen/Astroport.ONE/tools/my.sh
# Get script directory for relative imports
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default values
RELAYS="ws://127.0.0.1:7777,wss://relay.copylaradio.com"
FILE_SIZE=0
JSON_OUTPUT=false
AUTO_MODE=false
AUTO_FILE=""
NOSTR_SCRIPT="${HOME}/.zen/Astroport.ONE/tools/nostr_send_note.py"
PUBLISH_VIDEO_SCRIPT="${SCRIPT_DIR}/publish_nostr_video.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored messages
log_info() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${BLUE}ℹ${NC} $1" >&2
    fi
}

log_success() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${GREEN}✓${NC} $1" >&2
    fi
}

log_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

log_warning() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${YELLOW}⚠${NC} $1" >&2
    fi
}

# Function to print usage
usage() {
    cat << EOF
Usage: $0 --auto <upload_output.json> --nsec <nsec_key_or_file> [OPTIONS]
   or: $0 --nsec <nsec_key_or_file> --ipfs-cid <cid> --filename <name> --mime-type <type> [OPTIONS]

Required arguments:
  --nsec <key_or_file>      NSEC private key (nsec1...) or path to .secret.nostr file
  
  Auto mode:
  --auto <file>             Read parameters from upload2ipfs.sh JSON output
  
  Manual mode:
  --ipfs-cid <cid>          IPFS CID of the file
  --filename <name>         Filename
  --mime-type <type>        MIME type (determines NOSTR kind)

Optional arguments:
  --title <text>            File title/description
  --description <text>      Additional description
  --file-hash <sha256>      SHA256 hash of the file (for provenance)
  --info-cid <cid>          IPFS CID of info.json metadata file
  --upload-chain <chain>    Upload chain for provenance tracking
  --relays <urls>           Comma-separated relay URLs
  --json                    Output JSON format
  --help                    Show this help message

Examples:
  # With upload2ipfs.sh (recommended)
  $0 --auto /tmp/upload.json --nsec ~/.zen/secret.nostr --json

  # Manual mode
  $0 --nsec ~/.zen/secret.nostr \\
     --ipfs-cid QmXXX \\
     --filename document.pdf \\
     --mime-type application/pdf \\
     --json
EOF
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto)
            AUTO_MODE=true
            AUTO_FILE="$2"
            shift 2
            ;;
        --nsec)
            NSEC_INPUT="$2"
            shift 2
            ;;
        --ipfs-cid)
            IPFS_CID="$2"
            shift 2
            ;;
        --filename)
            FILENAME="$2"
            shift 2
            ;;
        --mime-type)
            MIME_TYPE="$2"
            shift 2
            ;;
        --title)
            TITLE="$2"
            shift 2
            ;;
        --description)
            DESCRIPTION="$2"
            shift 2
            ;;
        --file-hash)
            FILE_HASH="$2"
            shift 2
            ;;
        --info-cid)
            INFO_CID="$2"
            shift 2
            ;;
        --upload-chain)
            UPLOAD_CHAIN="$2"
            shift 2
            ;;
        --relays)
            RELAYS="$2"
            shift 2
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Auto mode: load parameters from upload2ipfs.sh output file
if [ "$AUTO_MODE" = "true" ]; then
    log_info "Auto mode enabled, reading from: $AUTO_FILE"
    
    if [ -z "$AUTO_FILE" ] || [ ! -f "$AUTO_FILE" ]; then
        log_error "Auto mode requires a valid upload2ipfs.sh output file"
        exit 1
    fi
    
    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        log_error "jq is required for auto mode"
        exit 1
    fi
    
    # Read JSON output from upload2ipfs.sh
    UPLOAD_DATA=$(cat "$AUTO_FILE")
    
    # Extract fields
    [ -z "$IPFS_CID" ] && IPFS_CID=$(echo "$UPLOAD_DATA" | jq -r '.cid // empty')
    [ -z "$FILENAME" ] && FILENAME=$(echo "$UPLOAD_DATA" | jq -r '.fileName // empty')
    [ -z "$FILE_HASH" ] && FILE_HASH=$(echo "$UPLOAD_DATA" | jq -r '.fileHash // empty')
    [ -z "$MIME_TYPE" ] && MIME_TYPE=$(echo "$UPLOAD_DATA" | jq -r '.mimeType // empty')
    [ -z "$INFO_CID" ] && INFO_CID=$(echo "$UPLOAD_DATA" | jq -r '.info // empty')
    # Extract file size (for NIP-94 size tag)
    FILE_SIZE=$(echo "$UPLOAD_DATA" | jq -r '.fileSize // 0')
    # Extract upload_chain - can be string (old format) or JSON array (new format)
    # Use -c to get compact JSON if it's an array, or -r for string
    if [ -z "$UPLOAD_CHAIN" ]; then
        UPLOAD_CHAIN_RAW=$(echo "$UPLOAD_DATA" | jq -c '.upload_chain // empty' 2>/dev/null || echo "")
        # Check if it's a JSON array or string
        if echo "$UPLOAD_CHAIN_RAW" | jq -e '. | type == "array"' >/dev/null 2>&1; then
            # It's an array, keep as compact JSON
            UPLOAD_CHAIN="$UPLOAD_CHAIN_RAW"
        else
            # It's a string or empty, extract as string
            UPLOAD_CHAIN=$(echo "$UPLOAD_DATA" | jq -r '.upload_chain // empty' 2>/dev/null || echo "")
        fi
    fi
    
    # Auto-generate title if not provided
    if [ -z "$TITLE" ]; then
        TITLE=$(echo "$UPLOAD_DATA" | jq -r '.title // empty')
        if [ -z "$TITLE" ]; then
            TITLE="$FILENAME"
        fi
    fi
    
    log_success "Loaded metadata from upload2ipfs.sh output"
    log_info "  CID: $IPFS_CID"
    log_info "  Filename: $FILENAME"
    log_info "  MIME type: $MIME_TYPE"
    [ -n "$FILE_HASH" ] && log_info "  File hash: ${FILE_HASH:0:16}..."
    [ -n "$UPLOAD_CHAIN" ] && log_info "  Upload chain: ${UPLOAD_CHAIN:0:50}..."
fi

# Validate required arguments
if [ -z "$NSEC_INPUT" ]; then
    log_error "Missing required argument: --nsec"
    usage
fi

if [ -z "$IPFS_CID" ]; then
    log_error "Missing required argument: --ipfs-cid (or --auto with valid file)"
    usage
fi

if [ -z "$FILENAME" ]; then
    log_error "Missing required argument: --filename (or --auto with valid file)"
    usage
fi

if [ -z "$MIME_TYPE" ]; then
    log_error "Missing required argument: --mime-type (or --auto with valid file)"
    usage
fi

# Determine event kind and handler based on MIME type
if [[ "$MIME_TYPE" == "video/"* ]]; then
    log_info "Video file detected, delegating to publish_nostr_video.sh..."
    
    # Check if publish_nostr_video.sh exists
    if [ ! -f "$PUBLISH_VIDEO_SCRIPT" ]; then
        log_error "publish_nostr_video.sh not found: $PUBLISH_VIDEO_SCRIPT"
        exit 1
    fi
    
    # Delegate to video-specific script
    # Pass through all relevant parameters
    VIDEO_CMD=("bash" "$PUBLISH_VIDEO_SCRIPT" "--nsec" "$NSEC_INPUT")
    
    if [ "$AUTO_MODE" = "true" ]; then
        VIDEO_CMD+=("--auto" "$AUTO_FILE")
    else
        VIDEO_CMD+=("--ipfs-cid" "$IPFS_CID" "--filename" "$FILENAME")
        [ -n "$FILE_HASH" ] && VIDEO_CMD+=("--file-hash" "$FILE_HASH")
        [ -n "$INFO_CID" ] && VIDEO_CMD+=("--info-cid" "$INFO_CID")
        [ -n "$UPLOAD_CHAIN" ] && VIDEO_CMD+=("--upload-chain" "$UPLOAD_CHAIN")
        [ -n "$MIME_TYPE" ] && VIDEO_CMD+=("--mime-type" "$MIME_TYPE")
    fi
    
    [ -n "$TITLE" ] && VIDEO_CMD+=("--title" "$TITLE")
    [ -n "$DESCRIPTION" ] && VIDEO_CMD+=("--description" "$DESCRIPTION")
    [ "$JSON_OUTPUT" = "true" ] && VIDEO_CMD+=("--json")
    
    # Execute video script
    exec "${VIDEO_CMD[@]}"
    
else
    # Handle non-video files with NIP-94 (kind 1063)
    log_info "Non-video file detected, publishing as NIP-94 (kind 1063)..."
    
    # Extract NSEC key
    if [ -f "$NSEC_INPUT" ]; then
        log_info "Reading NSEC from file: $NSEC_INPUT"
        NSEC_KEY=$(grep -oP 'NSEC=\K[^\s;]+' "$NSEC_INPUT" 2>/dev/null || echo "")
        if [ -z "$NSEC_KEY" ]; then
            log_error "Could not extract NSEC from file: $NSEC_INPUT"
            exit 1
        fi
        KEYFILE="$NSEC_INPUT"
    else
        NSEC_KEY="$NSEC_INPUT"
        TEMP_KEYFILE=$(mktemp)
        echo "NSEC=$NSEC_KEY" > "$TEMP_KEYFILE"
        KEYFILE="$TEMP_KEYFILE"
        log_info "Using provided NSEC key"
    fi
    
    # Build IPFS URL
    IPFS_URL="/ipfs/${IPFS_CID}/${FILENAME}"
    log_info "IPFS URL: $IPFS_URL"
    
    # Build content (NIP-94 uses empty content, all metadata in tags)
    FILE_CONTENT=""
    if [ -n "$DESCRIPTION" ]; then
        FILE_CONTENT="$DESCRIPTION"
    fi
    
    # Build NIP-94 tags
    log_info "Building NIP-94 tags..."
    
    TAGS='[
    ["url", "'"$IPFS_URL"'"],
    ["m", "'"$MIME_TYPE"'"]'
    
    # Add file size if available (NIP-94 standard)
    if [ -n "$FILE_SIZE" ] && [ "$FILE_SIZE" != "0" ]; then
        TAGS="${TAGS},
    [\"size\", \"${FILE_SIZE}\"]"
        log_info "Added file size: ${FILE_SIZE} bytes"
    fi
    
    # Add file hash if available (critical for provenance)
    if [ -n "$FILE_HASH" ]; then
        TAGS="${TAGS},
    [\"x\", \"${FILE_HASH}\"]"
        log_info "Added file hash for provenance: ${FILE_HASH:0:16}..."
    fi
    
    # Add dimensions for images (from upload2ipfs.sh)
    if [[ "$MIME_TYPE" == "image/"* ]]; then
        # Extract dimensions from auto mode or use provided value
        DIMENSIONS=""
        if [ "$AUTO_MODE" = "true" ] && [ -n "$UPLOAD_DATA" ]; then
            DIMENSIONS=$(echo "$UPLOAD_DATA" | jq -r '.dimensions // empty')
        fi
        
        if [ -n "$DIMENSIONS" ]; then
            TAGS="${TAGS},
    [\"dim\", \"${DIMENSIONS}\"]"
            log_info "Added image dimensions: $DIMENSIONS"
        fi
        
        # Add thumbnail CID if available (for non-JPG images converted to JPG)
        THUMBNAIL_CID=""
        if [ "$AUTO_MODE" = "true" ] && [ -n "$UPLOAD_DATA" ]; then
            THUMBNAIL_CID=$(echo "$UPLOAD_DATA" | jq -r '.thumbnail_ipfs // empty')
        fi
        
        if [ -n "$THUMBNAIL_CID" ]; then
            THUMBNAIL_URL="/ipfs/${THUMBNAIL_CID}"
            TAGS="${TAGS},
    [\"r\", \"${THUMBNAIL_URL}\", \"Thumbnail\"],
    [\"image\", \"${THUMBNAIL_URL}\"],
    [\"thumbnail_ipfs\", \"${THUMBNAIL_CID}\"]"
            log_info "Added image thumbnail: ${THUMBNAIL_CID:0:16}..."
        fi
    fi
    
    # Add duration for audio files (from upload2ipfs.sh)
    if [[ "$MIME_TYPE" == "audio/"* ]]; then
        DURATION=""
        if [ "$AUTO_MODE" = "true" ] && [ -n "$UPLOAD_DATA" ]; then
            DURATION=$(echo "$UPLOAD_DATA" | jq -r '.duration // empty')
        fi
        
        if [ -n "$DURATION" ] && [ "$DURATION" != "0" ]; then
            TAGS="${TAGS},
    [\"duration\", \"${DURATION}\"]"
            log_info "Added audio duration: ${DURATION}s"
        fi
    fi
    
    # Add info.json CID if available
    if [ -n "$INFO_CID" ]; then
        TAGS="${TAGS},
    [\"info\", \"${INFO_CID}\"]"
        log_info "Added info.json CID: $INFO_CID"
    fi
    
    # Add upload_chain if available (provenance tracking)
    if [ -n "$UPLOAD_CHAIN" ]; then
        # Use jq to properly escape the JSON string for insertion into tags array
        # The upload_chain can be a string (old format) or JSON array (new format)
        # Convert to string format for Nostr tag if it's a JSON array
        if command -v jq &> /dev/null; then
            # Check if UPLOAD_CHAIN is a JSON array (new format)
            if echo "$UPLOAD_CHAIN" | jq -e '. | type == "array"' >/dev/null 2>&1; then
                # Convert array to comma-separated string for Nostr tag (backward compatibility)
                UPLOAD_CHAIN_STR=$(echo "$UPLOAD_CHAIN" | jq -r '[.[].pubkey] | join(",")' 2>/dev/null || echo "$UPLOAD_CHAIN")
            else
                # Already a string, use as-is
                UPLOAD_CHAIN_STR="$UPLOAD_CHAIN"
            fi
            # Escape the string properly using jq -Rs (raw string, escape special chars)
            ESCAPED_CHAIN=$(echo "$UPLOAD_CHAIN_STR" | jq -Rs '.' | head -c -1)
            # jq -Rs outputs a JSON string (with quotes), use it directly in the tag
            TAGS="${TAGS},
    [\"upload_chain\", ${ESCAPED_CHAIN}]"
        else
            # Fallback: basic escaping (replace quotes and newlines)
            ESCAPED_CHAIN=$(echo "$UPLOAD_CHAIN" | sed 's/"/\\"/g' | tr '\n' ' ' | sed 's/  */ /g')
        TAGS="${TAGS},
    [\"upload_chain\", \"${ESCAPED_CHAIN}\"]"
        fi
        log_info "Added upload chain: ${UPLOAD_CHAIN:0:50}..."
    fi
    
    # Add title tag if provided
    if [ -n "$TITLE" ]; then
        TAGS="${TAGS},
    [\"title\", \"${TITLE}\"]"
    fi
    
    # Add description tag if provided
    if [ -n "$DESCRIPTION" ]; then
        TAGS="${TAGS},
    [\"description\", \"${DESCRIPTION}\"]"
    fi
    
    # Close tags array
    TAGS="${TAGS}
]"
    
    # Check if nostr_send_note.py exists
    if [ ! -f "$NOSTR_SCRIPT" ]; then
        log_error "NOSTR script not found: $NOSTR_SCRIPT"
        [ -n "$TEMP_KEYFILE" ] && rm -f "$TEMP_KEYFILE"
        exit 1
    fi
    
    # Publish to NOSTR (kind 1063 for NIP-94)
    log_info "Publishing to NOSTR relays (kind 1063)..."
    
    # Determine which Python3 to use (prefer ~/.astro/bin/python3 if available)
    PYTHON_CMD="python3"
    if [ -x "$HOME/.astro/bin/python3" ]; then
        PYTHON_CMD="$HOME/.astro/bin/python3"
    elif [ -x "/usr/bin/python3" ]; then
        PYTHON_CMD="/usr/bin/python3"
    fi
    
    log_info "Using Python: $PYTHON_CMD"
    
    NOSTR_OUTPUT=$($PYTHON_CMD "$NOSTR_SCRIPT" \
        --keyfile "$KEYFILE" \
        --content "$FILE_CONTENT" \
        --relays "$RELAYS" \
        --tags "$TAGS" \
        --kind "1063" \
        --json 2>&1)
    
    NOSTR_EXIT_CODE=$?
    
    # Clean up temporary keyfile if created
    [ -n "$TEMP_KEYFILE" ] && rm -f "$TEMP_KEYFILE"
    
    # Check result
    if [ $NOSTR_EXIT_CODE -eq 0 ]; then
        # Parse JSON output
        EVENT_ID=$(echo "$NOSTR_OUTPUT" | jq -r '.event_id // empty' 2>/dev/null || echo "")
        RELAYS_SUCCESS=$(echo "$NOSTR_OUTPUT" | jq -r '.relays_success // 0' 2>/dev/null || echo "0")
        RELAYS_TOTAL=$(echo "$NOSTR_OUTPUT" | jq -r '.relays_total // 0' 2>/dev/null || echo "0")
        
        if [ -z "$EVENT_ID" ]; then
            # Fallback to old parsing method
            EVENT_ID=$(echo "$NOSTR_OUTPUT" | grep -oP '(Event ID:|event_id:|- ID:)\s*\K[a-f0-9]{64}' | head -1 || echo "")
        fi
        
        if [ -n "$EVENT_ID" ]; then
            log_success "NOSTR event published successfully!"
            log_success "Event ID: $EVENT_ID"
            log_success "Kind: 1063 (NIP-94 File Metadata)"
            log_success "Published to $RELAYS_SUCCESS/$RELAYS_TOTAL relay(s)"
            
            if [ "$JSON_OUTPUT" = "true" ]; then
                cat << EOF
{
  "success": true,
  "event_id": "$EVENT_ID",
  "kind": 1063,
  "relays_success": $RELAYS_SUCCESS,
  "relays_total": $RELAYS_TOTAL,
  "ipfs_url": "$IPFS_URL",
  "mime_type": "$MIME_TYPE",
  "upload_chain": "${UPLOAD_CHAIN:-}"
}
EOF
            else
                echo "$EVENT_ID"
            fi
            exit 0
        else
            log_error "Event published but could not extract event ID"
            log_error "Output: $NOSTR_OUTPUT"
            exit 1
        fi
    else
        log_error "Failed to publish NOSTR event (exit code: $NOSTR_EXIT_CODE)"
        log_error "Output: $NOSTR_OUTPUT"
        if [ "$JSON_OUTPUT" = "true" ]; then
            cat << EOF
{
  "success": false,
  "error": "Failed to publish NOSTR event",
  "exit_code": $NOSTR_EXIT_CODE,
  "output": "$NOSTR_OUTPUT"
}
EOF
        fi
        exit 1
    fi
fi

