#!/bin/bash
################################################################################
# publish_nostr_video.sh - Unified NOSTR Video Event Publisher (NIP-71)
#
# This script publishes NIP-71 video events (kind 21/22) to NOSTR relays.
# It is designed to work in HARMONY with upload2ipfs.sh:
#
# WORKFLOW:
#   1. upload2ipfs.sh: Upload file to IPFS, generate metadata (thumbnail, GIF, info.json)
#   2. publish_nostr_video.sh: Publish NOSTR event with metadata from step 1
#
# The --auto mode allows seamless integration by reading upload2ipfs.sh JSON output.
#
# USAGE:
#   # Manual mode (all parameters explicit)
#   ./publish_nostr_video.sh --nsec <nsec_key_or_file> \
#                            --ipfs-cid <cid> \
#                            --filename <name> \
#                            [--title "My Video"] \
#                            [--description "Video description"] \
#                            [--thumbnail-cid <cid>] \
#                            [--gifanim-cid <cid>] \
#                            [--info-cid <cid>] \
#                            [--file-hash <sha256>] \
#                            [--mime-type "video/webm"] \
#                            [--upload-chain "npub1... -> npub2..."] \
#                            [--duration <seconds>] \
#                            [--dimensions "1920x1080"] \
#                            [--latitude <lat>] \
#                            [--longitude <lon>] \
#                            [--channel <name>] \
#                            [--relays "ws://host1,wss://host2"] \
#                            [--json]
#
#   # Auto mode (reads from upload2ipfs.sh output file)
#   ./publish_nostr_video.sh --auto <upload_output.json> \
#                            --nsec <nsec_key_or_file> \
#                            [--title "My Video"] \
#                            [--description "..."] \
#                            [--channel <name>] \
#                            [--latitude <lat>] \
#                            [--longitude <lon>] \
#                            [--json]
#
# RETURNS:
#   - Exit code 0 on success
#   - JSON output if --json flag is set
#   - Event ID printed to stdout
#
# EXAMPLES:
#   # Example 1: Integrated with upload2ipfs.sh (RECOMMENDED)
#   UPLOAD_OUTPUT="/tmp/upload_result.json"
#   upload2ipfs.sh video.mp4 "$UPLOAD_OUTPUT" "$USER_HEX"
#   publish_nostr_video.sh --auto "$UPLOAD_OUTPUT" \
#                          --nsec ~/.zen/game/players/user@example.com/.secret.nostr \
#                          --title "My Video" \
#                          --json
#
#   # Example 2: From bash (nostr_tube_manager.sh)
#   ./publish_nostr_video.sh --nsec ~/.zen/game/players/user@example.com/.secret.nostr \
#                            --ipfs-cid QmXXX \
#                            --filename video.webm \
#                            --title "My Video" \
#                            --thumbnail-cid QmYYY \
#                            --gifanim-cid QmZZZ \
#                            --json
#
#   # Example 3: From Python (54321.py)
#   result = subprocess.run([
#       "./publish_nostr_video.sh",
#       "--nsec", str(secret_file),
#       "--ipfs-cid", ipfs_cid,
#       "--filename", filename,
#       "--thumbnail-cid", thumbnail_cid,
#       "--gifanim-cid", gifanim_cid,
#       "--json"
#   ], capture_output=True, text=True)
#
# HARMONY WITH upload2ipfs.sh:
#   This script expects metadata generated by upload2ipfs.sh:
#   - IPFS CID (main file)
#   - thumbnail_ipfs (generated by upload2ipfs.sh for videos)
#   - gifanim_ipfs (generated by upload2ipfs.sh for videos)
#   - info.json CID (contains all metadata)
#   - file hash (SHA256, for provenance tracking)
#   - upload_chain (provenance: list of pubkeys that uploaded this file)
#
#   Upload2ipfs.sh should be called FIRST to generate these metadata,
#   then this script publishes the NOSTR event with complete metadata.
#
################################################################################

# Note: set -e removed to allow proper error handling with exit codes
# set -e
# Find uSPOT ENV
source $HOME/.zen/Astroport.ONE/tools/my.sh

# Default values
RELAYS="ws://127.0.0.1:7777,wss://relay.copylaradio.com"
MIME_TYPE="video/webm"
DURATION=0
FILE_SIZE=0
DIMENSIONS="640x480"
LATITUDE="0.00"
LONGITUDE="0.00"
SOURCE_TYPE=""
JSON_OUTPUT=false
AUTO_MODE=false
AUTO_FILE=""
NOSTR_SCRIPT="${HOME}/.zen/Astroport.ONE/tools/nostr_send_note.py"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored messages
log_info() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${BLUE}â„¹${NC} $1" >&2
    fi
}

log_success() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${GREEN}âœ“${NC} $1" >&2
    fi
}

log_error() {
    echo -e "${RED}âœ—${NC} $1" >&2
}

log_warning() {
    if [ "$JSON_OUTPUT" != "true" ]; then
        echo -e "${YELLOW}âš ${NC} $1" >&2
    fi
}

# Function to print usage
usage() {
    cat << EOF
Usage: $0 --nsec <nsec_key_or_file> --ipfs-cid <cid> --filename <name> [OPTIONS]

Required arguments:
  --nsec <key_or_file>      NSEC private key (nsec1...) or path to .secret.nostr file
  --ipfs-cid <cid>          IPFS CID of the video file
  --filename <name>         Filename of the video

Optional arguments:
  --title <text>            Video title (default: auto-generated from timestamp)
  --description <text>      Video description
  --thumbnail-cid <cid>     IPFS CID of thumbnail image
  --gifanim-cid <cid>       IPFS CID of animated GIF preview
  --info-cid <cid>          IPFS CID of info.json metadata file
  --file-hash <sha256>      SHA256 hash of the video file (for provenance)
  --mime-type <type>        MIME type (default: video/webm)
  --upload-chain <chain>    Upload chain for provenance tracking
  --duration <seconds>      Video duration in seconds (determines kind 21 vs 22)
  --dimensions <WxH>        Video dimensions (e.g., 1920x1080)
  --latitude <lat>          Geographic latitude (default: 0.00)
  --longitude <lon>         Geographic longitude (default: 0.00)
  --channel <name>          Channel name/email
  --source-type <type>      Source type: film, serie, youtube, webcam (auto-detected in --auto mode)
  --youtube-url <url>       YouTube URL (optional, auto-sets --source-type youtube if not set)
  --series-name <name>      Series name (for series/episodes)
  --episode-name <name>     Episode name/title (for series/episodes)
  --season-number <num>     Season number (for series/episodes)
  --episode-number <num>    Episode number (for series/episodes)
  --genres <json_array>     JSON array of genres (e.g., '["Action","Sci-Fi"]') - will publish kind 1985 tags
  --relays <urls>           Comma-separated relay URLs (default: local+copylaradio)
  --json                    Output JSON format
  --help                    Show this help message

Examples:
  $0 --nsec ~/.zen/game/players/user@example.com/.secret.nostr \\
     --ipfs-cid QmXXX \\
     --filename video.webm \\
     --title "My Video" \\
     --duration 120 \\
     --json
EOF
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto)
            AUTO_MODE=true
            AUTO_FILE="$2"
            shift 2
            ;;
        --nsec)
            NSEC_INPUT="$2"
            shift 2
            ;;
        --ipfs-cid)
            IPFS_CID="$2"
            shift 2
            ;;
        --filename)
            FILENAME="$2"
            shift 2
            ;;
        --title)
            TITLE="$2"
            shift 2
            ;;
        --description)
            DESCRIPTION="$2"
            shift 2
            ;;
        --thumbnail-cid)
            THUMBNAIL_CID="$2"
            shift 2
            ;;
        --gifanim-cid)
            GIFANIM_CID="$2"
            shift 2
            ;;
        --info-cid)
            INFO_CID="$2"
            shift 2
            ;;
        --file-hash)
            FILE_HASH="$2"
            shift 2
            ;;
        --mime-type)
            MIME_TYPE="$2"
            shift 2
            ;;
        --upload-chain)
            UPLOAD_CHAIN="$2"
            shift 2
            ;;
        --duration)
            DURATION="$2"
            shift 2
            ;;
        --dimensions)
            DIMENSIONS="$2"
            shift 2
            ;;
        --file-size)
            FILE_SIZE="$2"
            shift 2
            ;;
        --latitude)
            LATITUDE="$2"
            shift 2
            ;;
        --longitude)
            LONGITUDE="$2"
            shift 2
            ;;
        --channel)
            CHANNEL="$2"
            shift 2
            ;;
        --source-type)
            SOURCE_TYPE="$2"
            shift 2
            ;;
        --youtube-url)
            YOUTUBE_URL="$2"
            # Auto-set source type to youtube if not already set
            [[ -z "$SOURCE_TYPE" ]] && SOURCE_TYPE="youtube"
            shift 2
            ;;
        --series-name)
            SERIES_NAME="$2"
            shift 2
            ;;
        --episode-name)
            EPISODE_NAME="$2"
            shift 2
            ;;
        --season-number)
            SEASON_NUMBER="$2"
            shift 2
            ;;
        --episode-number)
            EPISODE_NUMBER="$2"
            shift 2
            ;;
        --genres)
            GENRES_JSON="$2"
            shift 2
            ;;
        --relays)
            RELAYS="$2"
            shift 2
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Auto mode: load parameters from upload2ipfs.sh output file
if [ "$AUTO_MODE" = "true" ]; then
    log_info "Auto mode enabled, reading from: $AUTO_FILE"
    
    if [ -z "$AUTO_FILE" ] || [ ! -f "$AUTO_FILE" ]; then
        log_error "Auto mode requires a valid upload2ipfs.sh output file"
        exit 1
    fi
    
    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        log_error "jq is required for auto mode"
        exit 1
    fi
    
    # Read JSON output from upload2ipfs.sh
    UPLOAD_DATA=$(cat "$AUTO_FILE")
    
    # Extract fields (only if not already provided via command line)
    [ -z "$IPFS_CID" ] && IPFS_CID=$(echo "$UPLOAD_DATA" | jq -r '.cid // empty')
    [ -z "$FILENAME" ] && FILENAME=$(echo "$UPLOAD_DATA" | jq -r '.fileName // empty')
    [ -z "$FILE_HASH" ] && FILE_HASH=$(echo "$UPLOAD_DATA" | jq -r '.fileHash // empty')
    [ -z "$MIME_TYPE" ] && MIME_TYPE=$(echo "$UPLOAD_DATA" | jq -r '.mimeType // "video/webm"')
    [ -z "$THUMBNAIL_CID" ] && THUMBNAIL_CID=$(echo "$UPLOAD_DATA" | jq -r '.thumbnail_ipfs // empty')
    [ -z "$GIFANIM_CID" ] && GIFANIM_CID=$(echo "$UPLOAD_DATA" | jq -r '.gifanim_ipfs // empty')
    [ -z "$INFO_CID" ] && INFO_CID=$(echo "$UPLOAD_DATA" | jq -r '.info // empty')
    [ -z "$UPLOAD_CHAIN" ] && UPLOAD_CHAIN=$(echo "$UPLOAD_DATA" | jq -r '.upload_chain // empty')
    [ -z "$DIMENSIONS" ] && DIMENSIONS=$(echo "$UPLOAD_DATA" | jq -r '.dimensions // "640x480"')
    # Extract file size (for NIP-71 size tag) - only if not provided via command line
    [ -z "$FILE_SIZE" ] || [ "$FILE_SIZE" = "0" ] && FILE_SIZE=$(echo "$UPLOAD_DATA" | jq -r '.fileSize // 0')
    
    # Auto-detect source type from upload2ipfs.sh metadata (only if not provided via command line)
    if [ -z "$SOURCE_TYPE" ]; then
        SOURCE_TYPE="webcam"  # Default: personal video/webcam
        if command -v jq &> /dev/null; then
            # Check for TMDB metadata (film/serie)
            TMDB_MEDIA_TYPE=$(echo "$UPLOAD_DATA" | jq -r '.tmdb.media_type // empty' 2>/dev/null)
            if [[ -n "$TMDB_MEDIA_TYPE" ]]; then
                if [[ "$TMDB_MEDIA_TYPE" == "movie" ]]; then
                    SOURCE_TYPE="film"
                elif [[ "$TMDB_MEDIA_TYPE" == "tv" ]]; then
                    SOURCE_TYPE="serie"
                fi
            else
                # Check for YouTube metadata
                YOUTUBE_VIDEO_ID=$(echo "$UPLOAD_DATA" | jq -r '.youtube.video_id // empty' 2>/dev/null)
                if [[ -n "$YOUTUBE_VIDEO_ID" ]]; then
                    SOURCE_TYPE="youtube"
                fi
            fi
        fi
    fi
    # Default to webcam if still empty
    SOURCE_TYPE=${SOURCE_TYPE:-webcam}
    log_info "Source type: $SOURCE_TYPE"
    
    # Extract series metadata from upload2ipfs.sh output (only if not already provided via command line)
    if [ -z "$SERIES_NAME" ] && command -v jq &> /dev/null; then
        # Try to get from tmdb.series_name first (preferred)
        SERIES_NAME=$(echo "$UPLOAD_DATA" | jq -r '.tmdb.series_name // empty' 2>/dev/null)
        # If not found, try tmdb.title (for series, this is the series name)
        if [[ -z "$SERIES_NAME" ]] && [[ "$SOURCE_TYPE" == "serie" ]]; then
            SERIES_NAME=$(echo "$UPLOAD_DATA" | jq -r '.tmdb.title // .tmdb.name // empty' 2>/dev/null)
        fi
    fi
    
    if [ -z "$EPISODE_NAME" ] && command -v jq &> /dev/null; then
        # Episode name in tmdb.episode_name (preferred) or tmdb.episode_title
        EPISODE_NAME=$(echo "$UPLOAD_DATA" | jq -r '.tmdb.episode_name // .tmdb.episode_title // empty' 2>/dev/null)
    fi
    
    if [ -z "$SEASON_NUMBER" ] && command -v jq &> /dev/null; then
        SEASON_NUMBER=$(echo "$UPLOAD_DATA" | jq -r '.tmdb.season_number // empty' 2>/dev/null)
        # Convert to string if it's a number
        [[ -n "$SEASON_NUMBER" ]] && [[ "$SEASON_NUMBER" != "null" ]] && SEASON_NUMBER=$(echo "$SEASON_NUMBER" | awk '{print int($1)}')
    fi
    
    if [ -z "$EPISODE_NUMBER" ] && command -v jq &> /dev/null; then
        EPISODE_NUMBER=$(echo "$UPLOAD_DATA" | jq -r '.tmdb.episode_number // empty' 2>/dev/null)
        # Convert to string if it's a number
        [[ -n "$EPISODE_NUMBER" ]] && [[ "$EPISODE_NUMBER" != "null" ]] && EPISODE_NUMBER=$(echo "$EPISODE_NUMBER" | awk '{print int($1)}')
    fi
    
    # Extract genres from upload2ipfs.sh output (only if not already provided via command line)
    if [ -z "$GENRES_JSON" ] && command -v jq &> /dev/null; then
        GENRES_JSON=$(echo "$UPLOAD_DATA" | jq -c '.tmdb.genres // []' 2>/dev/null)
        # If empty or null, try empty array
        [[ -z "$GENRES_JSON" ]] || [[ "$GENRES_JSON" == "null" ]] && GENRES_JSON="[]"
    fi
    
    # Extract duration (convert to integer)
    if [ -z "$DURATION" ] || [ "$DURATION" = "0" ]; then
        DURATION_RAW=$(echo "$UPLOAD_DATA" | jq -r '.duration // 0')
        DURATION=$(echo "$DURATION_RAW" | awk '{print int($1)}')
    else
        # Convert duration to integer if it's a decimal (always convert for comparison)
        DURATION=$(echo "$DURATION" | awk '{print int($1)}')
    fi
    
    # Auto-generate title if not provided
    if [ -z "$TITLE" ]; then
        TITLE=$(echo "$UPLOAD_DATA" | jq -r '.title // empty')
        if [ -z "$TITLE" ]; then
            TITLE="Video $(date '+%Y-%m-%d %H:%M')"
        fi
    fi
    
    log_success "Loaded metadata from upload2ipfs.sh output"
    log_info "  CID: $IPFS_CID"
    log_info "  Filename: $FILENAME"
    log_info "  Duration: ${DURATION}s"
    [ -n "$THUMBNAIL_CID" ] && log_info "  Thumbnail: ${THUMBNAIL_CID:0:16}..."
    [ -n "$GIFANIM_CID" ] && log_info "  Animated GIF: ${GIFANIM_CID:0:16}..."
    [ -n "$UPLOAD_CHAIN" ] && log_info "  Upload chain: ${UPLOAD_CHAIN:0:50}..."
fi

# Validate required arguments
if [ -z "$NSEC_INPUT" ]; then
    log_error "Missing required argument: --nsec"
    usage
fi

if [ -z "$IPFS_CID" ]; then
    log_error "Missing required argument: --ipfs-cid (or --auto with valid file)"
    usage
fi

if [ -z "$FILENAME" ]; then
    log_error "Missing required argument: --filename (or --auto with valid file)"
    usage
fi

# Extract NSEC key
if [ -f "$NSEC_INPUT" ]; then
    # It's a file, extract NSEC from it
    log_info "Reading NSEC from file: $NSEC_INPUT"
    NSEC_KEY=$(grep -oP 'NSEC=\K[^\s;]+' "$NSEC_INPUT" 2>/dev/null || echo "")
    if [ -z "$NSEC_KEY" ]; then
        log_error "Could not extract NSEC from file: $NSEC_INPUT"
        exit 1
    fi
    KEYFILE="$NSEC_INPUT"
else
    # Assume it's a direct NSEC key
    NSEC_KEY="$NSEC_INPUT"
    # Create temporary keyfile
    TEMP_KEYFILE=$(mktemp)
    echo "NSEC=$NSEC_KEY" > "$TEMP_KEYFILE"
    KEYFILE="$TEMP_KEYFILE"
    log_info "Using provided NSEC key"
fi

# Generate default title if not provided
if [ -z "$TITLE" ]; then
    TITLE="Video recording $(date '+%Y-%m-%d %H:%M')"
    log_info "Using default title: $TITLE"
fi

# Ensure DURATION is an integer (convert if decimal) - required for comparison
if [ -n "$DURATION" ] && [ "$DURATION" != "0" ]; then
    DURATION=$(echo "$DURATION" | awk '{print int($1)}')
fi
# Default to 0 if not set
DURATION=${DURATION:-0}

# Determine video kind based on duration (22 for â‰¤60s, 21 for >60s)
if [ "$DURATION" -le 60 ]; then
    VIDEO_KIND="22"
    log_info "Video kind: 22 (short video, â‰¤60s)"
else
    VIDEO_KIND="21"
    log_info "Video kind: 21 (regular video, >60s)"
fi

# Build IPFS URL
# Encode the filename for URL safety
ENCODED_FILENAME=$(python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))" "$FILENAME")
IPFS_URL="/ipfs/${IPFS_CID}/${ENCODED_FILENAME}"
log_info "IPFS URL: $IPFS_URL"

# Build video content (compatible with /webcam)
VIDEO_CONTENT="ðŸŽ¬ ${TITLE}"
if [ -n "$DESCRIPTION" ]; then
    VIDEO_CONTENT="${VIDEO_CONTENT}
ðŸ“ Description: ${DESCRIPTION}"
fi

log_info "Building NOSTR tags..."

# Build tags array (compatible with NIP-71 and create_video_channel.py)
TAGS='[
    ["title", "'"$TITLE"'"],
    ["url", "'"$IPFS_URL"'"],
    ["m", "'"$MIME_TYPE"'"],
    ["imeta", "dim '"$DIMENSIONS"'", "url '"$IPFS_URL"'"'

# Add file hash to imeta if available
if [ -n "$FILE_HASH" ]; then
    TAGS="${TAGS}, \"x ${FILE_HASH}\", \"m ${MIME_TYPE}\""
    log_info "Added file hash to imeta: ${FILE_HASH:0:16}..."
fi

TAGS="${TAGS}],
    [\"duration\", \"$DURATION\"]"
    
# Add file size tag (NIP-71 standard) - always add even if 0 for consistency
if [ -n "$FILE_SIZE" ]; then
    TAGS="${TAGS},
    [\"size\", \"$FILE_SIZE\"]"
    log_info "Added file size: ${FILE_SIZE} bytes"
fi

TAGS="${TAGS},
    [\"published_at\", \"$(date +%s)\"],
    [\"t\", \"YouTubeDownload\"],
    [\"t\", \"VideoChannel\"]"

# Add short/regular video tag
if [ "$DURATION" -le 60 ]; then
    TAGS="${TAGS},
    [\"t\", \"ShortVideo\"]"
else
    TAGS="${TAGS},
    [\"t\", \"RegularVideo\"]"
fi

# Add channel tag if provided
if [ -n "$CHANNEL" ]; then
    CHANNEL_TAG=$(echo "$CHANNEL" | sed 's/@/_/g; s/\./_/g')
    TAGS="${TAGS},
    [\"t\", \"Channel-${CHANNEL_TAG}\"]"
    log_info "Added channel tag: Channel-${CHANNEL_TAG}"
fi

# Add geographic coordinates (UMAP anchoring)
TAGS="${TAGS},
    [\"g\", \"${LATITUDE},${LONGITUDE}\"],
    [\"location\", \"${LATITUDE},${LONGITUDE}\"],
    [\"latitude\", \"${LATITUDE}\"],
    [\"longitude\", \"${LONGITUDE}\"]"
log_info "Added location: ${LATITUDE}, ${LONGITUDE}"

# Add thumbnail if available
if [ -n "$THUMBNAIL_CID" ]; then
    THUMBNAIL_URL="/ipfs/${THUMBNAIL_CID}"
    TAGS="${TAGS},
    [\"r\", \"${THUMBNAIL_URL}\", \"Thumbnail\"],
    [\"image\", \"${THUMBNAIL_URL}\"],
    [\"thumbnail_ipfs\", \"${THUMBNAIL_CID}\"]"
    log_info "Added thumbnail: ${THUMBNAIL_CID}"
fi

# Add animated GIF if available
if [ -n "$GIFANIM_CID" ]; then
    GIFANIM_URL="/ipfs/${GIFANIM_CID}"
    TAGS="${TAGS},
    [\"gifanim_ipfs\", \"${GIFANIM_CID}\"]"
    log_info "Added animated GIF: ${GIFANIM_CID}"
fi

# Add info.json CID if available
if [ -n "$INFO_CID" ]; then
    TAGS="${TAGS},
    [\"info\", \"${INFO_CID}\"]"
    log_info "Added info.json: ${INFO_CID}"
fi

# Add direct 'x' tag for file hash (provenance)
if [ -n "$FILE_HASH" ]; then
    TAGS="${TAGS},
    [\"x\", \"${FILE_HASH}\"]"
    log_info "Added provenance 'x' tag: ${FILE_HASH:0:16}..."
fi

# Add source type tag (film, serie, youtube, webcam)
if [ -n "$SOURCE_TYPE" ]; then
    TAGS="${TAGS},
    [\"i\", \"source:${SOURCE_TYPE}\"]"
    log_info "Added source type tag: source:${SOURCE_TYPE}"
fi

# Add series metadata tags (for series/episodes)
if [ -n "$SERIES_NAME" ]; then
    TAGS="${TAGS},
    [\"series_name\", \"${SERIES_NAME}\"]"
    log_info "Added series name: ${SERIES_NAME}"
fi

if [ -n "$EPISODE_NAME" ]; then
    TAGS="${TAGS},
    [\"episode_name\", \"${EPISODE_NAME}\"]"
    log_info "Added episode name: ${EPISODE_NAME}"
fi

if [ -n "$SEASON_NUMBER" ]; then
    TAGS="${TAGS},
    [\"season_number\", \"${SEASON_NUMBER}\"]"
    log_info "Added season number: ${SEASON_NUMBER}"
fi

if [ -n "$EPISODE_NUMBER" ]; then
    TAGS="${TAGS},
    [\"episode_number\", \"${EPISODE_NUMBER}\"]"
    log_info "Added episode number: ${EPISODE_NUMBER}"
fi

# Add upload_chain if this is a re-upload
if [ -n "$UPLOAD_CHAIN" ]; then
    # Use jq to properly escape the JSON string for insertion into tags array
    # The upload_chain is a JSON string that needs to be escaped as a tag value
    if command -v jq &> /dev/null; then
        # Escape the JSON string properly using jq -Rs (raw string, escape special chars)
        # This will properly escape quotes, newlines, etc. for JSON
        ESCAPED_CHAIN=$(echo "$UPLOAD_CHAIN" | jq -Rs '.' | head -c -1)
        # jq -Rs outputs a JSON string (with quotes), use it directly in the tag
        TAGS="${TAGS},
    [\"upload_chain\", ${ESCAPED_CHAIN}]"
    else
        # Fallback: basic escaping (replace quotes and newlines)
        ESCAPED_CHAIN=$(echo "$UPLOAD_CHAIN" | sed 's/"/\\"/g' | tr '\n' ' ' | sed 's/  */ /g')
    TAGS="${TAGS},
    [\"upload_chain\", \"${ESCAPED_CHAIN}\"]"
    fi
    log_info "Added upload chain: ${UPLOAD_CHAIN:0:50}..."
fi

# Close tags array
TAGS="${TAGS}
]"

# Check if nostr_send_note.py exists
if [ ! -f "$NOSTR_SCRIPT" ]; then
    log_error "NOSTR script not found: $NOSTR_SCRIPT"
    if [ -n "$TEMP_KEYFILE" ]; then
        rm -f "$TEMP_KEYFILE"
    fi
    exit 1
fi

# Publish to NOSTR
log_info "Publishing to NOSTR relays..."
log_info "Command: python3 $NOSTR_SCRIPT --keyfile <keyfile> --content <content> --relays $RELAYS --tags <tags> --kind $VIDEO_KIND --json"

# Determine which Python3 to use (prefer ~/.astro/bin/python3 if available)
PYTHON_CMD="python3"
if [ -x "$HOME/.astro/bin/python3" ]; then
    PYTHON_CMD="$HOME/.astro/bin/python3"
elif [ -x "/usr/bin/python3" ]; then
    PYTHON_CMD="/usr/bin/python3"
fi

log_info "Using Python: $PYTHON_CMD"

# Execute nostr_send_note.py
NOSTR_OUTPUT=$($PYTHON_CMD "$NOSTR_SCRIPT" \
    --keyfile "$KEYFILE" \
    --content "$VIDEO_CONTENT" \
    --relays "$RELAYS" \
    --tags "$TAGS" \
    --kind "$VIDEO_KIND" \
    --json 2>&1)

NOSTR_EXIT_CODE=$?

# Clean up temporary keyfile if created
if [ -n "$TEMP_KEYFILE" ]; then
    rm -f "$TEMP_KEYFILE"
fi

# Check result
if [ $NOSTR_EXIT_CODE -eq 0 ]; then
    # Parse JSON output
    EVENT_ID=$(echo "$NOSTR_OUTPUT" | jq -r '.event_id // empty' 2>/dev/null || echo "")
    RELAYS_SUCCESS=$(echo "$NOSTR_OUTPUT" | jq -r '.relays_success // 0' 2>/dev/null || echo "0")
    RELAYS_TOTAL=$(echo "$NOSTR_OUTPUT" | jq -r '.relays_total // 0' 2>/dev/null || echo "0")
    
    if [ -z "$EVENT_ID" ]; then
        # Fallback to old parsing method
        EVENT_ID=$(echo "$NOSTR_OUTPUT" | grep -oP '(Event ID:|event_id:|- ID:)\s*\K[a-f0-9]{64}' | head -1 || echo "")
    fi
    
    if [ -n "$EVENT_ID" ]; then
        log_success "NOSTR event published successfully!"
        log_success "Event ID: $EVENT_ID"
        log_success "Published to $RELAYS_SUCCESS/$RELAYS_TOTAL relay(s)"
        
        # Publish a kind 1 note on user's wall with theater link
        log_info "Publishing kind 1 note with theater link..."
        
        # Build theater URL
        [[ "$uSPOT" == "http://127.0.0.1:54321" ]] && uSPOT="https://u.copylaradio.com"
        THEATER_URL="${uSPOT}/theater?video=${EVENT_ID}"
        
        # Build kind 1 content with emojis and theater link
        KIND1_CONTENT="ðŸŽ¬ ${TITLE}

ðŸ“¹ New video !
ðŸŽ¥ Watch here: ${THEATER_URL}

Duration: ${DURATION}s
IPFS: /ipfs/${IPFS_CID}

#video #UPlanet"
        
        # Build kind 1 tags with video reference
        KIND1_TAGS="[
    [\"e\", \"${EVENT_ID}\", \"\", \"mention\"],
    [\"t\", \"video\"],
    [\"t\", \"UPlanet\"]"
        
        # Add location tags if provided
        if [ "$LATITUDE" != "0.00" ] || [ "$LONGITUDE" != "0.00" ]; then
            KIND1_TAGS="${KIND1_TAGS},
    [\"g\", \"${LATITUDE},${LONGITUDE}\"]"
        fi
        
        KIND1_TAGS="${KIND1_TAGS}
]"
        
        # Re-create keyfile for kind 1 publication
        if [ -f "$NSEC_INPUT" ]; then
            KIND1_KEYFILE="$NSEC_INPUT"
        else
            KIND1_TEMP_KEYFILE=$(mktemp)
            echo "NSEC=$NSEC_KEY" > "$KIND1_TEMP_KEYFILE"
            KIND1_KEYFILE="$KIND1_TEMP_KEYFILE"
        fi
        
        # Publish kind 1 note
        KIND1_OUTPUT=$($PYTHON_CMD "$NOSTR_SCRIPT" \
            --keyfile "$KIND1_KEYFILE" \
            --content "$KIND1_CONTENT" \
            --relays "$RELAYS" \
            --tags "$KIND1_TAGS" \
            --kind "1" \
            --json 2>&1)
        
        KIND1_EXIT_CODE=$?
        
        # Clean up temporary keyfile if created
        [ -n "$KIND1_TEMP_KEYFILE" ] && rm -f "$KIND1_TEMP_KEYFILE"
        
        if [ $KIND1_EXIT_CODE -eq 0 ]; then
            KIND1_EVENT_ID=$(echo "$KIND1_OUTPUT" | jq -r '.event_id // empty' 2>/dev/null || echo "")
            if [ -n "$KIND1_EVENT_ID" ]; then
                log_success "Kind 1 note published: ${KIND1_EVENT_ID:0:16}..."
            else
                log_warning "Kind 1 note might have been published but ID not extracted"
            fi
        else
            log_warning "Failed to publish kind 1 note (non-critical): $KIND1_OUTPUT"
        fi
        
        # Publish kind 1985 tag events for each genre (NIP-32 Labeling)
        if [ -n "$GENRES_JSON" ] && [ "$GENRES_JSON" != "[]" ] && [ "$GENRES_JSON" != "null" ]; then
            log_info "Publishing kind 1985 tag events for genres..."
            
            # Parse genres array
            if command -v jq &> /dev/null; then
                # Get first relay URL for tag events
                FIRST_RELAY=$(echo "$RELAYS" | cut -d',' -f1 | tr -d ' ')
                
                # Extract each genre and publish a kind 1985 event
                # Use process substitution to avoid subshell issues
                GENRE_COUNT=0
                while IFS= read -r genre; do
                    # Skip empty genres
                    [[ -z "$genre" ]] && continue
                    
                    # Normalize genre: lowercase, replace spaces with hyphens, remove special chars
                    NORMALIZED_GENRE=$(echo "$genre" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
                    
                    # Skip if normalization resulted in empty string
                    [[ -z "$NORMALIZED_GENRE" ]] && continue
                    
                    log_info "Publishing tag event for genre: $NORMALIZED_GENRE (from: $genre)"
                    
                    # Build tags for kind 1985 (NIP-32 format)
                    # Format: ["L", "ugc"], ["l", "<tag_value>", "ugc"], ["e", "<video_event_id>", "<relay_url>"], ["k", "<video_kind>"]
                    TAG_EVENT_TAGS="[[\"L\",\"ugc\"],[\"l\",\"${NORMALIZED_GENRE}\",\"ugc\"],[\"e\",\"${EVENT_ID}\",\"${FIRST_RELAY}\"],[\"k\",\"${VIDEO_KIND}\"]]"
                    
                    # Publish kind 1985 event using nostr_send_note.py
                    TAG_EVENT_OUTPUT=$($PYTHON_CMD "$NOSTR_SCRIPT" \
                        --keyfile "$KEYFILE" \
                        --content "" \
                        --relays "$RELAYS" \
                        --tags "$TAG_EVENT_TAGS" \
                        --kind 1985 \
                        --json 2>&1)
                    
                    TAG_EVENT_EXIT_CODE=$?
                    
                    if [ $TAG_EVENT_EXIT_CODE -eq 0 ]; then
                        TAG_EVENT_ID=$(echo "$TAG_EVENT_OUTPUT" | jq -r '.event_id // empty' 2>/dev/null || echo "")
                        if [ -n "$TAG_EVENT_ID" ]; then
                            log_success "Tag event published for genre '$NORMALIZED_GENRE': ${TAG_EVENT_ID:0:16}..."
                            GENRE_COUNT=$((GENRE_COUNT + 1))
                        else
                            log_warning "Tag event published for genre '$NORMALIZED_GENRE' but could not extract event ID"
                        fi
                    else
                        log_warning "Failed to publish tag event for genre '$NORMALIZED_GENRE' (non-critical): $TAG_EVENT_OUTPUT"
                    fi
                done < <(echo "$GENRES_JSON" | jq -r '.[]' 2>/dev/null)
                
                if [ $GENRE_COUNT -gt 0 ]; then
                    log_success "Published $GENRE_COUNT genre tag event(s)"
                fi
            else
                log_warning "jq not available, skipping genre tag publication"
            fi
        fi
        
        if [ "$JSON_OUTPUT" = "true" ]; then
            # Escape upload_chain for JSON output using jq
            UPLOAD_CHAIN_JSON=""
            if [ -n "$UPLOAD_CHAIN" ]; then
                if command -v jq &> /dev/null; then
                    # Escape the string properly for JSON
                    UPLOAD_CHAIN_JSON=$(echo "$UPLOAD_CHAIN" | jq -Rs '.' | head -c -1)
                else
                    # Fallback: basic escaping
                    UPLOAD_CHAIN_JSON=$(echo "$UPLOAD_CHAIN" | sed 's/"/\\"/g' | sed 's/\\/\\\\/g')
                    UPLOAD_CHAIN_JSON="\"$UPLOAD_CHAIN_JSON\""
                fi
            else
                UPLOAD_CHAIN_JSON='""'
            fi
            
            # Output JSON format
            cat << EOF
{
  "success": true,
  "event_id": "$EVENT_ID",
  "kind": $VIDEO_KIND,
  "relays_success": $RELAYS_SUCCESS,
  "relays_total": $RELAYS_TOTAL,
  "ipfs_url": "$IPFS_URL",
  "title": "$TITLE",
  "duration": $DURATION,
  "upload_chain": ${UPLOAD_CHAIN_JSON},
  "kind1_note_id": "${KIND1_EVENT_ID:-}"
}
EOF
        else
            echo "$EVENT_ID"
        fi
        exit 0
    else
        log_error "Event published but could not extract event ID"
        log_error "Output: $NOSTR_OUTPUT"
        exit 1
    fi
else
    log_error "Failed to publish NOSTR event (exit code: $NOSTR_EXIT_CODE)"
    log_error "Output: $NOSTR_OUTPUT"
    if [ "$JSON_OUTPUT" = "true" ]; then
        cat << EOF
{
  "success": false,
  "error": "Failed to publish NOSTR event",
  "exit_code": $NOSTR_EXIT_CODE,
  "output": "$NOSTR_OUTPUT"
}
EOF
    fi
    exit 1
fi

